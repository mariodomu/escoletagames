<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Memory Match (Kids)</title>
  <style>
    :root {
      --bg1: #fff6d8;
      --bg2: #ffe4ec;
      --panel: rgba(255, 255, 255, 0.85);
      --card-back: #5aa9ff;
      --card-back-2: #7cc3ff;
      --card-face: #ffffff;
      --back-pattern-a: rgba(255,255,255,.26);
      --back-pattern-b: rgba(255,255,255,.12);
      --center-a: #fff1a8;
      --center-b: #ffd86b;
      --text: #2d2d2d;
      --gap: clamp(10px, 1.8vmin, 18px);
      --radius: clamp(14px, 2.2vmin, 24px);
      --shadow: 0 10px 24px rgba(0, 0, 0, 0.14);
    }

    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text);
      overflow: hidden;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      background:
        radial-gradient(circle at 15% 15%, rgba(255,255,255,.7), transparent 35%),
        radial-gradient(circle at 80% 20%, rgba(255,255,255,.6), transparent 30%),
        radial-gradient(circle at 30% 85%, rgba(255,255,255,.5), transparent 35%),
        linear-gradient(135deg, var(--bg1), var(--bg2));
      display: grid;
      place-items: center;
    }

    .app {
      width: 100%;
      height: 100%;
      padding: clamp(10px, 2.2vmin, 22px);
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 10px;
    }

    .hud {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 10px;
      z-index: 3;
    }

    .control {
      border: 0;
      background: var(--panel);
      color: var(--text);
      border-radius: 999px;
      padding: 10px 14px;
      font-size: clamp(14px, 1.8vmin, 18px);
      box-shadow: var(--shadow);
      cursor: pointer;
    }

    .control:active { transform: translateY(1px); }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding-right: 12px;
    }

    .toggle input {
      width: 22px;
      height: 22px;
      cursor: pointer;
    }

    .stage {
      position: relative;
      display: grid;
      place-items: center;
      min-height: 0;
    }

    .board {
      width: min(92vmin, 900px);
      height: min(92vmin, 900px);
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: var(--gap);
      padding: var(--gap);
      border-radius: calc(var(--radius) + 6px);
      background: rgba(255, 255, 255, 0.22);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.3), 0 16px 40px rgba(0,0,0,.12);
      backdrop-filter: blur(4px);
    }

    .tile {
      position: relative;
      border: 0;
      border-radius: var(--radius);
      overflow: hidden;
      box-shadow: var(--shadow);
      cursor: pointer;
      background: var(--card-face);
      transition: transform 140ms ease, box-shadow 140ms ease;
    }

    .tile.shake {
      animation: shakeCard 420ms ease;
    }

    .tile.match-pop {
      animation: matchPop 560ms cubic-bezier(.2,.9,.2,1);
    }

    .tile:not(.matched):not(.face-up):active {
      transform: scale(0.98);
    }

    .tile[disabled] {
      cursor: default;
    }

    .tile-inner {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
    }

    .tile-back.back {
      background:
        radial-gradient(circle at 20% 20%, var(--back-pattern-a) 0 7px, transparent 8px),
        radial-gradient(circle at 75% 35%, var(--back-pattern-b) 0 6px, transparent 7px),
        radial-gradient(circle at 40% 70%, var(--back-pattern-a) 0 8px, transparent 9px),
        repeating-linear-gradient(
          45deg,
          rgba(255,255,255,.08) 0 12px,
          rgba(255,255,255,.02) 12px 24px
        ),
        linear-gradient(145deg, #4f8dff, #66c7ff 55%, #7ae7c4);
    }

    .tile-back.back::after {
      content: "";
      position: absolute;
      inset: 12%;
      border-radius: calc(var(--radius) - 4px);
      border: 3px dashed rgba(255,255,255,.5);
      pointer-events: none;
    }

    .tile.face-up .tile-back { display: none; }
    .tile:not(.face-up) .tile-front { display: none; }

    .tile-front {
      background: linear-gradient(180deg, #fff, #f8fbff);
    }

    .tile-front img {
      width: 78%;
      height: 78%;
      object-fit: contain;
      display: block;
      pointer-events: none;
    }

    .label {
      position: absolute;
      left: 8px;
      right: 8px;
      bottom: 6px;
      font-size: clamp(10px, 1.1vmin, 12px);
      line-height: 1.1;
      text-align: center;
      background: rgba(255,255,255,.9);
      border-radius: 999px;
      padding: 3px 6px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity: 0.9;
    }

    .tile.matched {
      box-shadow: 0 0 0 4px rgba(91, 221, 123, .45), var(--shadow);
    }

    .center-tile {
      position: relative;
      border-radius: var(--radius);
      background:
        radial-gradient(circle at 30% 25%, rgba(255,255,255,.65), transparent 40%),
        linear-gradient(145deg, var(--center-a), var(--center-b));
      box-shadow: var(--shadow);
      display: grid;
      place-items: center;
      font-size: clamp(44px, 7vmin, 84px);
    }

    .center-tile::after {
      content: "";
      position: absolute;
      inset: 10%;
      border-radius: calc(var(--radius) - 4px);
      border: 3px solid rgba(255,255,255,.45);
    }

    .fx-layer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 4;
    }

    .spark {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 2px;
      opacity: 0;
      animation: pop 700ms ease-out forwards;
      transform: translate(-50%, -50%);
    }

    @keyframes pop {
      0%   { opacity: 0; transform: translate(-50%, -50%) scale(.4); }
      15%  { opacity: 1; }
      100% {
        opacity: 0;
        transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) rotate(var(--rot)) scale(1);
      }
    }

    @keyframes shakeCard {
      0%, 100% { transform: translateX(0) scale(1); }
      20% { transform: translateX(-8px) rotate(-1deg); }
      40% { transform: translateX(8px) rotate(1deg); }
      60% { transform: translateX(-6px) rotate(-0.5deg); }
      80% { transform: translateX(6px) rotate(0.5deg); }
    }

    @keyframes matchPop {
      0% { transform: scale(1); }
      30% { transform: scale(1.14) rotate(-1deg); }
      65% { transform: scale(1.08) rotate(1deg); }
      100% { transform: scale(1); }
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(255, 255, 255, 0.55);
      backdrop-filter: blur(3px);
      z-index: 5;
      opacity: 0;
      pointer-events: none;
      transition: opacity 220ms ease;
    }

    .overlay.show {
      opacity: 1;
      pointer-events: auto;
    }

    .overlay-card {
      background: rgba(255,255,255,.95);
      border-radius: 26px;
      padding: 22px 22px 18px;
      box-shadow: 0 18px 40px rgba(0,0,0,.16);
      text-align: center;
      min-width: min(82vw, 340px);
    }

    .overlay-emoji {
      font-size: clamp(56px, 10vmin, 96px);
      line-height: 1;
    }

    .overlay-text {
      margin-top: 8px;
      font-size: clamp(18px, 2.6vmin, 28px);
      font-weight: 700;
    }

    .play-again {
      margin-top: 12px;
      border: 0;
      border-radius: 999px;
      padding: 12px 20px;
      font-size: clamp(16px, 2vmin, 22px);
      background: #4cc06a;
      color: white;
      font-weight: 700;
      cursor: pointer;
      box-shadow: var(--shadow);
    }

    .play-again:active { transform: translateY(1px); }

    @media (max-width: 640px) {
      .hud {
        justify-content: center;
        flex-wrap: wrap;
      }
      .board {
        width: 96vmin;
        height: 96vmin;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="hud">
      <label class="control toggle" title="Briefly show all cards at start">
        <input id="previewToggle" type="checkbox" checked />
        <span>üëÄ Preview</span>
      </label>
      <button id="resetBtn" class="control" type="button" aria-label="Reset game">‚Üª Reset</button>
    </div>

    <div class="stage">
      <div id="board" class="board" aria-label="Memory Match Board"></div>

      <div id="overlay" class="overlay" aria-hidden="true">
        <div class="overlay-card">
          <div class="overlay-emoji">üéâ</div>
          <div class="overlay-text">Yay!</div>
          <button id="playAgainBtn" class="play-again" type="button">Play Again</button>
        </div>
      </div>
    </div>
  </div>

  <div id="fxLayer" class="fx-layer" aria-hidden="true"></div>

  <script>
    // =========================
    // EASY-TO-EDIT SETTINGS
    // =========================
    const GRID_SIZE = 3;              // fixed 3x3
    const MISMATCH_DELAY_MS = 1800;   // friendly delay before flipping back
    const SHOW_LABELS = false;        // teacher-only labels on cards

    // Replace these with your own kid-friendly images (works offline if paths are valid).
    const ASSETS = [
      { id: "a", label: "Oscar",    src: "assets/oscar.jpg" },
      { id: "b", label: "Lluna",    src: "assets/lluna.jpg" },
      { id: "c", label: "Monstre",  src: "assets/monstre.jpg" },
      { id: "d", label: "Escoleta", src: "assets/escoleta.png" },
    ];

    // =========================
    // GAME STATE
    // =========================
    const TOTAL_CELLS = GRID_SIZE * GRID_SIZE; // 9
    const CENTER_INDEX = 4; // row 2, col 2 in a 3x3 grid (0-based index in flat array)

    const boardEl = document.getElementById("board");
    const overlayEl = document.getElementById("overlay");
    const playAgainBtn = document.getElementById("playAgainBtn");
    const resetBtn = document.getElementById("resetBtn");
    const previewToggle = document.getElementById("previewToggle");
    const fxLayer = document.getElementById("fxLayer");

    let tiles = []; // 9 slots; center is a special star tile, others are card objects
    let firstPickIndex = null;
    let secondPickIndex = null;
    let isLocked = false;
    let matchedPairs = 0;

    // Lazy-created on first interaction (browser policy).
    let audioCtx = null;

    function ensureAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === "suspended") audioCtx.resume();
    }

    function playTone({ freq = 660, time = 0.12, type = "sine", volume = 0.03, when = 0 }) {
      if (!audioCtx) return;
      const t0 = audioCtx.currentTime + when;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = type;
      osc.frequency.setValueAtTime(freq, t0);

      gain.gain.setValueAtTime(0.0001, t0);
      gain.gain.exponentialRampToValueAtTime(volume, t0 + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, t0 + time);

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.start(t0);
      osc.stop(t0 + time + 0.02);
    }

    function playMatchSound() {
      playTone({ freq: 660, time: 0.12, type: "triangle", volume: 0.03, when: 0.00 });
      playTone({ freq: 880, time: 0.16, type: "triangle", volume: 0.03, when: 0.08 });
    }

    function playWinSound() {
      [523, 659, 784, 1047].forEach((f, i) => {
        playTone({ freq: f, time: 0.18, type: "sine", volume: 0.03, when: i * 0.08 });
      });
    }

    function shuffle(arr) {
      // Fisher-Yates
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function makeDeck() {
      const chosen = ASSETS.slice(0, 4); // game needs exactly 4 pairs
      const pairCards = chosen.flatMap(asset => [
        { ...asset, uid: crypto.randomUUID ? crypto.randomUUID() : `${asset.id}-1-${Math.random()}` },
        { ...asset, uid: crypto.randomUUID ? crypto.randomUUID() : `${asset.id}-2-${Math.random()}` },
      ]);
      return shuffle(pairCards);
    }

    function buildBoardState() {
      const deck = makeDeck();
      let d = 0;
      const next = [];

      for (let i = 0; i < TOTAL_CELLS; i++) {
        if (i === CENTER_INDEX) {
          next.push({ kind: "star" });
        } else {
          next.push({
            kind: "card",
            asset: deck[d++],
            revealed: false,
            matched: false,
          });
        }
      }
      return next;
    }

    function createCardTile(index, cell) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "tile";
      btn.dataset.index = String(index);
      btn.setAttribute("aria-label", cell.asset.label || "Card");

      const back = document.createElement("div");
      back.className = "tile-inner tile-back back";

      const front = document.createElement("div");
      front.className = "tile-inner tile-front";

      const img = document.createElement("img");
      img.alt = cell.asset.label || "";
      img.src = cell.asset.src;
      img.draggable = false;
      front.appendChild(img);

      if (SHOW_LABELS) {
        const label = document.createElement("div");
        label.className = "label";
        label.textContent = cell.asset.label || cell.asset.id;
        front.appendChild(label);
      }

      btn.appendChild(back);
      btn.appendChild(front);

      if (cell.revealed) btn.classList.add("face-up");
      if (cell.matched) btn.classList.add("matched");
      if (cell.shake) btn.classList.add("shake");
      if (cell.matchPop) btn.classList.add("match-pop");

      if (cell.matched || isLocked) btn.disabled = true;

      btn.addEventListener("click", () => onTileClick(index));
      return btn;
    }

    function createCenterTile() {
      const div = document.createElement("div");
      div.className = "center-tile";
      div.setAttribute("aria-label", "Star");
      div.textContent = "‚≠ê";
      return div;
    }

    function render() {
      boardEl.innerHTML = "";
      for (let i = 0; i < tiles.length; i++) {
        const cell = tiles[i];
        if (cell.kind === "star") {
          boardEl.appendChild(createCenterTile());
        } else {
          boardEl.appendChild(createCardTile(i, cell));
        }
      }
    }

    function updateOne() {
      // Simple + reliable for this tiny board: re-render all.
      render();
    }

    function hideOverlay() {
      overlayEl.classList.remove("show");
      overlayEl.setAttribute("aria-hidden", "true");
    }

    function showOverlay() {
      overlayEl.classList.add("show");
      overlayEl.setAttribute("aria-hidden", "false");
    }

    function celebrateAtTile(index, burstCount = 14, spread = 140) {
      const tileEl = boardEl.children[index];
      if (!tileEl) return;

      const r = tileEl.getBoundingClientRect();
      const x = r.left + r.width / 2;
      const y = r.top + r.height / 2;

      const colors = ["#ffd84d", "#ff7aa2", "#5ad3ff", "#7be37b", "#b18cff"];
      for (let i = 0; i < burstCount; i++) {
        const p = document.createElement("div");
        p.className = "spark";
        p.style.left = `${x}px`;
        p.style.top = `${y}px`;
        p.style.background = colors[i % colors.length];
        p.style.setProperty("--dx", `${(Math.random() * spread - spread / 2).toFixed(1)}px`);
        p.style.setProperty("--dy", `${(Math.random() * spread - spread / 2).toFixed(1)}px`);
        p.style.setProperty("--rot", `${Math.floor(Math.random() * 360)}deg`);
        p.style.animationDuration = `${550 + Math.random() * 250}ms`;
        fxLayer.appendChild(p);
        p.addEventListener("animationend", () => p.remove(), { once: true });
      }
    }

    function celebrateWin() {
      const points = [
        [window.innerWidth * 0.25, window.innerHeight * 0.30],
        [window.innerWidth * 0.50, window.innerHeight * 0.22],
        [window.innerWidth * 0.75, window.innerHeight * 0.32],
        [window.innerWidth * 0.35, window.innerHeight * 0.55],
        [window.innerWidth * 0.65, window.innerHeight * 0.58],
      ];
      points.forEach((point, idx) => {
        setTimeout(() => {
          const x = point[0];
          const y = point[1];
          for (let i = 0; i < 16; i++) {
            const p = document.createElement("div");
            p.className = "spark";
            p.style.left = `${x}px`;
            p.style.top = `${y}px`;
            p.style.background = ["#ffd84d", "#ff7aa2", "#5ad3ff", "#7be37b"][i % 4];
            p.style.setProperty("--dx", `${(Math.random() * 220 - 110).toFixed(1)}px`);
            p.style.setProperty("--dy", `${(Math.random() * 180 - 90).toFixed(1)}px`);
            p.style.setProperty("--rot", `${Math.floor(Math.random() * 360)}deg`);
            p.style.animationDuration = `${700 + Math.random() * 350}ms`;
            fxLayer.appendChild(p);
            p.addEventListener("animationend", () => p.remove(), { once: true });
          }
        }, idx * 120);
      });
    }

    function isClickableCard(index) {
      const cell = tiles[index];
      return cell && cell.kind === "card" && !cell.revealed && !cell.matched && !isLocked;
    }

    function onTileClick(index) {
      if (!isClickableCard(index)) return;

      ensureAudio();

      const cell = tiles[index];
      cell.revealed = true;
      updateOne();

      if (firstPickIndex === null) {
        firstPickIndex = index;
        return;
      }

      secondPickIndex = index;
      isLocked = true;
      render();

      const first = tiles[firstPickIndex];
      const second = tiles[secondPickIndex];
      const isMatch = first.asset.id === second.asset.id;

      if (isMatch) {
        first.matchPop = true;
        second.matchPop = true;
        first.matched = true;
        second.matched = true;
        matchedPairs++;
        playMatchSound();
        celebrateAtTile(firstPickIndex, 28, 240);
        celebrateAtTile(secondPickIndex, 28, 240);

        setTimeout(() => {
          first.matchPop = false;
          second.matchPop = false;
          render();
        }, 560);

        setTimeout(() => {
          firstPickIndex = null;
          secondPickIndex = null;
          isLocked = false;
          render();

          if (matchedPairs === 4) {
            playWinSound();
            celebrateWin();
            showOverlay();
          }
        }, 320);
      } else {
        first.shake = true;
        second.shake = true;
        render();

        setTimeout(() => {
          first.shake = false;
          second.shake = false;
          render();
        }, 430);

        setTimeout(() => {
          first.revealed = false;
          second.revealed = false;
          firstPickIndex = null;
          secondPickIndex = null;
          isLocked = false;
          render();
        }, MISMATCH_DELAY_MS);
      }
    }

    function revealAllCards() {
      tiles.forEach(cell => {
        if (cell.kind === "card") cell.revealed = true;
      });
      render();
    }

    function hideUnmatchedCards() {
      tiles.forEach(cell => {
        if (cell.kind === "card" && !cell.matched) cell.revealed = false;
      });
      render();
    }

    function startPreviewIfEnabled() {
      if (!previewToggle.checked) return;
      isLocked = true;
      revealAllCards();
      setTimeout(() => {
        hideUnmatchedCards();
        isLocked = false;
        render();
      }, 2000);
    }

    function resetGame() {
      firstPickIndex = null;
      secondPickIndex = null;
      isLocked = false;
      matchedPairs = 0;
      hideOverlay();
      tiles = buildBoardState();
      render();
      startPreviewIfEnabled();
    }

    resetBtn.addEventListener("click", resetGame);
    playAgainBtn.addEventListener("click", resetGame);
    document.addEventListener("dragstart", e => e.preventDefault());

    resetGame();
  </script>
</body>
</html>
